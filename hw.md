#程序的一次执行过程
在程序的一次执行中，操作系统首先为程序分配地址空间，操作系统管理内存的方式有**内存分段**，**内存分页**等等，我们主要来讨论一下内存分段。

内存分段的出现最开始是为了解决cpu的寻址能力不足的问题，如intel 8086cpu中十六位的寄存器无法存下20位的地址，于是我们就用了两个寄存器去存放数据即段寄存器和变址寄存器。但后来的主要作用是为了方便编程、信息共享、信息保护、动态增长、动态链接。操作系统将程序的地址空间分为若干个段，包括**代码段**（CS）、**数据段**（DS）、**堆栈段**（SS）及**附加段**，因此一个数据的物理地址=段号+段内地址。cpu中还存在一个**指令指针寄存器**（IP），它里面保存的是指令的偏移量，即它和CS的组合就与**程序计数器**（PC）的功能一样，用来记录当前的指令。![](https://i.imgur.com/rQIhmnG.png)
当cpu读取一条指令时，它会先将指令保存在**指令寄存器中**，然后指令经过**译码器**的到有效的操作码和地址码，接着cpu就会进行执行阶段，若是在执行阶段中要用到相关操作数，则cpu会根据变址寄存器加段寄存器得到操作数的物理地址，将地址通过地址总线发送出去，主存则将数据通过数据总线传回来。

**注**：这里要提到的一点是，在cpu中还有个**段表寄存器**来实现从逻辑地址到物理地址的映射。![](https://i.imgur.com/9UIplfD.png)

继续上面的话题，当我们的cpu在指令的执行过程完成后若没有后续的相关操作（如将结果写回存储器等等），那么cpu就会读取下一条指令，同时IP要加一。

其实在这里我们可以看出cpu完成一条指令的过程是分步骤完成的，这是我们不得不提到cpu的工作模式--**流水线型**的工作模式，就等于说我们把一个任务拆分成多个步骤，每个人去完成一个步骤，但同时我们也得规定一个人完成的时间限制，这就是cpu中的**时序**，这是由cpu中的振荡器产生的。
我们不妨把cpu执行指令的过程分为如下几个阶段

1.**取指**

2.**指令译码**

3.**计算操作数地址**

4.**取操作数**

5.**执行指令**

6.**写操作数**

当一个指令开始执行后，当第一个器件完成了取指工作后，它把工作交给下一个器件，那么第一个器件又可以继续取下一条指令，就是说当一个周期过后，每个器件都在工作，并且一个指令周期完成一个指令，效率比起早期的cpu有了较大的提升。这里我还得说一点，器件之间是怎么交接工作的呢？当然要靠存储，因为存储才使得状态得以延续，所以两个期间件还得有一个**流水寄存器**。这就是我们说的标量流水线。但是如果我们仔细的想一想，假设第二个指令需要用到第一个指令的结果，但是第一个指令并没有执行完，这就会出现问题，我们的解决办法是让第二个指令“等待”，直到第一个指令执行完成。这就是数据相关会带来的问题，我们还有控制相关和结构相关。
![](https://i.imgur.com/5jz7ZBo.png)

其实在这样的效率基础上我们还能提升，**超标量流水线**就能满足这一要求，他能同一时间执行多个指令（这多个指令要求互相独立），最后能在一个指令周期内完成多条指令。![](https://i.imgur.com/9TDeFtk.png)
这是多发技术的其中之一。



##中断系统
我们接下来简单介绍一下中断系统。
计算机在运行过程中可能会遇到许多异常或者说需要cpu紧急解决的问题，
如敲键盘会引起中断、停电也会引起中断。cpu需要根据**向量地址**找到中断入口并作出响应。

cpu中有一个**中断请求标记寄存器**，里面表明了各种中断类型，如果类型越多说明计算机处理中断的能力强。如果有这类型的中断请求，那么它相应的中断请求触发器会变为高电平。
我们cpu一次只能对一个中断作出响应，若是有多个中断请求，那么cpu会根据优先级来处理，如停电的优先级高于I/O设备的中断。

或者说有另一种情况，cpu在执行指令时遇到中断请求，那么它会将当前的程序断点存入堆栈，当完成中断响应后，cpu又继续执行上一个程序，这就是cpu保护现场，恢复现场的能力。
