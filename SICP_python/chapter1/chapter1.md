# 第一章 #

在第一章我们需要明白一个编程语言需要由哪些部分来组成，哪些以及将实际问题转为编程问题的时候我们需要进行哪些思想上的转换，这是第一章主要想要告诉我们的。

每一种强大的编程语言都有如下三种机制：   
1、基本的表达式和语句。  
2、组合的手段。  
3、抽象的手段。

# 表达式 #
表达式由操作符和操作数组成。对表达式求值时，先对操作符求值，得到运算规则后再讲操作数代入(注意：操作数可能也是一个表达式)。

调用表达式就是我们说的函数调用，它的操作符就是函数名，操作数就是括号里的参数。相对于中缀符来说，调用表达式可以有任意个操作数，它就比前者灵活。

嵌套表达式的求解是一种递归的求解，从root一直找到叶子节点，如图：  ![](https://i.imgur.com/BGZqdkh.png)


# 名称和环境 #

如果一个值被给予了名称，我们就说这个名称绑定到了值上面。将名称绑定到值上是一种最简单的抽象手段。一个客观对象如果有了名字，那么我们就可以在环境里找到它的名字，并通过它的名字访问他的本体。如果说你的名字在全局范围内有声明，那么我局部的环境也能访问你。但是如果你是在局部的环境里声明的名称，那么全局的环境及其他的局部环境就无法知道你这个局部的名称。有了环境，才不会使我们的名称产生混乱。

# 定义新的函数 #

    def <name>(<formal parameters>):
        return <return expression>

        这是用户定义函数的格式。   
        我们举一个例子   

            from operator import add, mul
                def square(x):
                        return mul(x, x)
                            def sum_squares(x, y):
                                    return add(square(x), square(y))
                                        sum_squares(5, 12)

                                        ![](https://i.imgur.com/glKJrKV.png)

                                        我们可以看到左上角最大的矩形框代表的是全局环境中拥有的名称，而下面的三个矩形框是代表的三个局部环境所拥有的名称。全局环境中的两个名称指向了它所绑定的函数。我们可以看到为什么两个相同的x名称不会引起混淆，是因为每计算一个函数时它都回创建一个局部帧。

                                        下面是选择名称的五个要点:  
                                        1、函数名称应该小写，以下划线分隔。提倡描述性的名称。  
                                        2、函数名称通常反映解释器向参数应用的操作（例如print、add、3、square），或者结果（例如max、abs、sum）。  
                                        3、参数名称应小写，以下划线分隔。提倡单个词的名称。  
                                        4、参数名称应该反映参数在函数中的作用，并不仅仅是满足的值的类型。  
                                        5、当作用非常明确时，单个字母的参数名称可以接受，但是永远不要使用l（小写的L）和O（大写的o），或者I（大写的i）来避免和数字混淆。

# 函数的抽象 #

在我们写代码时，我们可能会是先知道我们需要这样的功能，但我们可以将实现与功能独立开来，先摒弃实现的细节，先假设我们有这样的函数，一直到最后再去实现细节，这样做的好处是我们并没有为特定的情况去写函数。上面做个过程就是函数的抽象。

# 语句 #

语句跟表达式所不同的是，语句是改变程序当前的状态。我们所面临的情况是很复杂的，不一定是一步一步的按照步骤进行，可能出现一些突发情况需要进行优先处理。所以说控制语句就起到了很大的作用，它能使我们的程序更强大，能解决更多的问题。 
 
     if<expression>: 
            <suite>  
                elif <expression>:  
                    <suite>  
                        else:  
                                <suite>  
                                如这样的结构。

# 高阶函数 #

我们定义操作函数的函数称为高阶函数。这是一种更高级的抽象手段，极大提升语言的表现力。代码中会反复出现一些常见的编程模式，但是使用一些不同函数来实现。这些模式也可以被抽象和给予名称。通过这种方式，我们的代码不会变的冗余，而是变得更清晰明了。

    >>> def summation(n, term, next):
            total, k = 0, 1
                    while k <= n:
                                    total, k = total + term(k), next(k)
                                            return total
                                            这个地方，term和next就是我们所需要的函数，相当于我们提供了一个模板，按这个模板计算的具体问题会得到不同的结果。
                                            
                                            
                                            局部定义的函数作为返回值时，能提高语言的表现力。
                                            
# 装饰器 #
                                            
                                            装饰器的原理就是利用了高阶函数。
                                            
                                                >>> def trace1(fn):
                                                            def wrapped(x):
                                                                            print('-> ', fn, '(', x, ')')
                                                                                            return fn(x)
                                                                                                    return wrapped
                                                                                                        >>> @trace1
                                                                                                                def triple(x):
                                                                                                                        return 3 * x
                                                                                                                            >>> triple(12)
                                                                                                                                ->  <function triple at 0x102a39848> ( 12 )
                                                                                                                                    36


                                                                                                                                    trace1相当于为triple做了装饰而为traple添加新的功能。triple不跟它紧挨着的函数定义绑定在一起，而是绑定在wrapped上。那个未被绑定的函数体是fn。

                                                                                                                                        >>> def triple(x):
                                                                                                                                                return 3 * x
                                                                                                                                                    >>> triple = trace1(triple)

                                                                                                                                                    看出两者相等。
